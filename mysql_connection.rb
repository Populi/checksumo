require "mysql2"
require "logging"
require "memoist"

require_relative "log_helper"

# Checksum Result
class AbstractChecksum
  attr_accessor :crc32, :primary_key, :table_name

  def initialize(opts = {})
    @crc32 = opts.fetch(:crc32, nil)
    @primary_key = opts.fetch(:primary_key, nil)
    @table_name = opts.fetch(:table_name, nil)
  end
end

# Checksum for a "chunk" of a table: a list of consecutive rows
class ChunkChecksum < AbstractChecksum
  attr_accessor :count, :max, :min

  def initialize(opts = {})
    super
    @count = opts.fetch(:count, 0)
    @min = opts.fetch(:min, "")
    @max = opts.fetch(:max, "")
  end

  def equal?(other)
    !other.nil? &&
      other.class == self.class &&
      other.min == min &&
      other.max == max &&
      other.count == count &&
      other.crc32 == crc32
  end
end

# Checksum for a single row
class RowChecksum < AbstractChecksum
  attr_accessor :row_id

  def initialize(opts = {})
    super
    @row_id = opts.fetch(:row_id, "")
  end

  def equal?(other)
    !other.nil? &&
      other.class == self.class &&
      other.row_id == row_id &&
      other.crc32 == crc32
  end
end

# Encapsulate MySQL connection
class MysqlConnection
  extend Memoist

  attr_accessor :table_cache, :table_names, :primary_key_cache

  def initialize(opts = {})
    host = opts.fetch(:host, "")
    port = opts.fetch(:port, "")
    password = opts.fetch(:password, "")
    username = opts.fetch(:username, "")

    @primary_key_cache = Hash[]
    @table_names = []

    @client = opts.fetch(:client) do
      Mysql2::Client.new(host: host,
                         port: port,
                         username: username,
                         password: password)
    end

    @logger = opts.fetch(:logger) do
      LogHelper.logger(name: "#{self.class}")
    end
  end

  # Add table names to check.
  # If no tables are named here, a list can be generated by #search
  def check(table_names)
    @table_names << table_names
  end

  def search
    query = <<~QUERY
        SELECT t.table_name as TableName, group_concat(k.column_name separator ', ') as PrimaryKey
      FROM information_schema.table_constraints t
      LEFT JOIN information_schema.key_column_usage k
      USING(constraint_name,table_schema,table_name)
      WHERE t.constraint_type='PRIMARY KEY'
          AND t.table_schema=DATABASE()
      GROUP BY t.table_name;
    QUERY

    @client.query(query).each do |row|
      @primary_key_cache[row["TableName"]] = row["PrimaryKey"] unless row["PrimaryKey"].match(",")
    end

    @primary_key_cache
  end

  def columns(table_name)
    query = %(SELECT * FROM #{table_name} LIMIT 1;)
    result = @client.query(query)
    result.fields.sort
  end

  memoize :columns

  def primary_key(table_name, _opts = {})
    @primary_key_cache.fetch(table_name) do |name|
      statement = primary_key_query
      result_set = statement.execute(name)
      cols = result_set.map do |row|
        row["COLUMN_NAME"]
      end
      cols.join("::")
    end
  end

  memoize :primary_key # ? this might not be worth memoizing

  def max_row_id(table_name)
    primary_key = primary_key(table_name)
    query = %{SELECT COALESCE(max(#{primary_key}), "") as max from #{table_name};}
    maxes = @client.query(query).map do |row|
      row["max"]
    end

    maxes.first
  end

  memoize :max_row_id

  def min_row_id(table_name)
    primary_key = primary_key(table_name)
    query = %{SELECT COALESCE(min(#{primary_key}), "") as min from #{table_name};}
    maxes = @client.query(query).map do |row|
      row["min"]
    end

    maxes.first
  end

  memoize :min_row_id

  def row_checksum(table_name, opts = {})
    row_id = opts.fetch(:row_id, nil)
    primary_key = primary_key(table_name)
    statement = row_checksum_query(table_name)
    if !row_id.nil?
      result = statement.execute(row_id, row_id)
    else
      min = opts.fetch(:min) { min_row_id(table_name) }
      max = opts.fetch(:max) { max_row_id(table_name) }
      result = statement.execute(min, max)
    end
    result.map do |row|
      RowChecksum.new(table_name: table_name, row_id: row["ROW_ID"], crc32: row["CHECKSUM"], primary_key: primary_key)
    end
  end

  def chunk_checksum(table_name, opts = {})
    min = opts.fetch(:min) { min_row_id(table_name) }
    max = opts.fetch(:max) { max_row_id(table_name) }
    limit = opts.fetch(:limit, 0)

    primary_key = primary_key(table_name)

    result = if limit.positive?
        chunk_checksum_unbounded(table_name, min, limit)
      else
        chunk_checksum_bounded(table_name, min, max)
      end

    result.map do |row|
      ChunkChecksum.new(table_name: table_name,
                        crc32: row["CHECKSUM"],
                        count: row["COUNT"],
                        min: row["START"],
                        max: row["END"],
                        primary_key: primary_key)
    end
  end

  def generate_delete(table_name, row_id)
    statement = select_all_query(table_name)
    cmd = statement.execute(row_id).map do |row|
      wc = row.map do |k, v|
        if v.nil?
          %(#{k} IS NULL)
        else
          %(#{k} = '#{v}')
        end
      end
      %(DELETE FROM #{table_name} WHERE #{wc.join(" \nAND ")};)
    end
    @logger.debug("generated delete command #{cmd}")
    cmd
  end

  def generate_insert(table_name, row_id)
    statement = select_all_query(table_name)
    cmd = statement.execute(row_id).map do |row|
      cols = []
      vals = []
      row.each do |k, v|
        cols.push k
        val = if v.nil?
            "NULL"
          else
            %('#{v}')
          end
        vals.push(val)
      end
      %(INSERT INTO #{table_name} (#{cols.join(", ")})
                           VALUES (#{vals.join(", ")});)
    end
    @logger.debug("generated insert command #{cmd}")
    cmd
  end

  def generate_update(table_name, row_id)
    primary_key = primary_key(table_name)
    statement = select_all_query(table_name)
    cmd = statement.execute(row_id).map do |row|
      pairs = row.filter { |k, v| !k.eql?(primary_key) }.map do |k, v|
        val = if v.nil?
            "NULL"
          else
            %('#{v}')
          end
        %(#{k} = #{val})
      end
      %(UPDATE #{table_name} SET #{pairs.join(",\n\t\t")}
         WHERE #{primary_key} = '#{row_id}';)
    end
    @logger.debug("generated insert command #{cmd}")
    cmd
  end

  private

  def chunk_checksum_bounded(table_name, min, max)
    statement = chunk_checksum_query_bounded(table_name)
    statement.execute(min, max)
  end

  def chunk_checksum_unbounded(table_name, min, limit)
    statement = chunk_checksum_query_unbounded(table_name)
    statement.execute(min, limit)
  end

  def primary_key_query
    query = <<~QUERY
      SELECT k.COLUMN_NAME as COLUMN_NAME
      FROM information_schema.table_constraints t
      LEFT JOIN information_schema.key_column_usage k
      USING(constraint_name,table_schema,table_name)
      WHERE t.constraint_type='PRIMARY KEY'
      	AND t.table_schema=DATABASE()
      	AND t.table_name=?;
    QUERY

    @logger.debug("query: #{query}")

    @client.prepare(query)
  end

  memoize :primary_key_query

  def chunk_checksum_query_bounded(table_name)
    col_str = columns(table_name).map do |col|
      %{COALESCE(#{table_name}.#{col}, "")}
    end.join(", ")

    pk = primary_key(table_name)

    query = <<~QUERY
      SELECT COALESCE(min(t.#{pk}), "") as START,
        COALESCE(max(t.#{pk}), "") as END,
        COALESCE(count(t.#{pk}), 0) as COUNT,
        COALESCE(CRC32(group_concat(t.CHECKSUM separator '|')), 0) as CHECKSUM

        FROM(SELECT #{pk}, CRC32(CONCAT(#{col_str})) as CHECKSUM
          FROM #{table_name}
          WHERE #{table_name}.#{pk} >= ? and #{table_name}.#{pk} <= ?) as t;
    QUERY

    @client.prepare(query)
  end

  memoize :chunk_checksum_query_bounded

  def chunk_checksum_query_unbounded(table_name)
    col_str = columns(table_name).map do |col|
      %{COALESCE(#{table_name}.#{col}, "")}
    end.join(", ")

    pk = primary_key(table_name)

    query = <<~QUERY
      SELECT COALESCE(min(t.#{pk}), "") as START,
        COALESCE(max(t.#{pk}), "") as END,
        COALESCE(count(t.#{pk}), 0) as COUNT,
        COALESCE(CRC32(group_concat(t.CHECKSUM separator '|')), 0) as CHECKSUM

        FROM(SELECT #{pk}, CRC32(CONCAT(#{col_str})) as CHECKSUM
          FROM #{table_name}
          WHERE #{table_name}.#{pk} >= ?
          LIMIT ?) as t;
    QUERY

    @client.prepare(query)
  end

  memoize :chunk_checksum_query_unbounded

  def row_checksum_query(table_name)
    col_str = columns(table_name).map do |col|
      %{COALESCE(#{table_name}.#{col}, "")}
    end.join(", ")

    pk = primary_key(table_name)

    query = <<~QUERY
      SELECT #{pk} as ROW_ID, CRC32(CONCAT(#{col_str})) as CHECKSUM
      FROM #{table_name}
      WHERE #{pk} >= ? and #{pk} <= ?
    QUERY

    @logger.info("generated row checksum query: #{query}")

    @client.prepare(query)
  end

  memoize :row_checksum_query

  def select_all_query(table_name)
    primary_key = primary_key(table_name)
    query = %(select * from #{table_name} where #{primary_key} = ?)
    @client.prepare(query)
  end

  memoize :select_all_query
end
